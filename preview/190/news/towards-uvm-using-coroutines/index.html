<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=5">
<link href=/preview/190/vendor/bootstrap/bootstrap.min.css rel=stylesheet>
<link href=/preview/190/vendor/phosphor-icons/css/phosphor.css rel=stylesheet>
<link href=/preview/190/vendor/magnific-popup/magnific-popup.css rel=stylesheet>
<link rel=stylesheet href=/preview/190/scss/theme.min.53fa887b01836c4fd2231659f9c9f611f2bfeb6c256dfea6461be73843594049.css>
<link rel=icon href=/preview/190/images/favicon/cropped-favicon-1-32x32.png sizes=32x32>
<link rel=icon href=/preview/190/images/favicon/cropped-favicon-1-192x192.png sizes=192x192>
<link rel=apple-touch-icon href=/preview/190/images/favicon/cropped-favicon-1-180x180.png>
<meta name=msapplication-TileImage content="/preview/190/images/favicon/cropped-favicon-1-270x270.png">
<script src=https://cmp.osano.com/16A0DbT9yDNIaQkvZ/3b49aaa9-15ab-4d47-a8fb-96cc25b5543c/osano.js></script>
<title>Towards UVM: Using Coroutines for Low-overhead Dynamic Scheduling in Verilator | CHIPS Alliance</title>
<meta name=description content="This post was originally published at Antmicro.
Verilator is a popular open source SystemVerilog simulator and one of the key tools in the ASIC and …">
<meta property="og:title" content="Towards UVM: Using Coroutines for Low-overhead Dynamic Scheduling in Verilator">
<meta property="og:description" content="This post was originally published at Antmicro.
Verilator is a popular open source SystemVerilog simulator and one of the key tools in the ASIC and FPGA ecosystem, which Antmicro is actively using and developing, e.g. by enabling co-simulation with Renode or Cocotb integration. It’s also one of the fastest available HDL simulators, including proprietary alternatives. It achieves that speed by generating highly optimized C++ code from a given hardware design. Verilator does a lot of work at compile-time to make the generated (‘verilated’) code extremely fast, such as ordering statements in an optimal way.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://chipsalliance.org/preview/190/news/towards-uvm-using-coroutines/"><meta property="og:image" content="https://chipsalliance.org/preview/190/news/towards-uvm-using-coroutines/share.png"><meta property="article:section" content="news">
<meta property="article:published_time" content="2022-02-01T00:00:00+00:00">
<meta property="article:modified_time" content="2022-02-01T00:00:00+00:00"><meta property="og:site_name" content="CHIPS Alliance">
<meta itemprop=name content="Towards UVM: Using Coroutines for Low-overhead Dynamic Scheduling in Verilator">
<meta itemprop=description content="This post was originally published at Antmicro.
Verilator is a popular open source SystemVerilog simulator and one of the key tools in the ASIC and FPGA ecosystem, which Antmicro is actively using and developing, e.g. by enabling co-simulation with Renode or Cocotb integration. It’s also one of the fastest available HDL simulators, including proprietary alternatives. It achieves that speed by generating highly optimized C++ code from a given hardware design. Verilator does a lot of work at compile-time to make the generated (‘verilated’) code extremely fast, such as ordering statements in an optimal way."><meta itemprop=datePublished content="2022-02-01T00:00:00+00:00">
<meta itemprop=dateModified content="2022-02-01T00:00:00+00:00">
<meta itemprop=wordCount content="1621"><meta itemprop=image content="https://chipsalliance.org/preview/190/news/towards-uvm-using-coroutines/share.png">
<meta itemprop=keywords content="project-update,verilator,uvm,"><meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://chipsalliance.org/preview/190/news/towards-uvm-using-coroutines/share.png">
<meta name=twitter:title content="Towards UVM: Using Coroutines for Low-overhead Dynamic Scheduling in Verilator">
<meta name=twitter:description content="This post was originally published at Antmicro.
Verilator is a popular open source SystemVerilog simulator and one of the key tools in the ASIC and FPGA ecosystem, which Antmicro is actively using and developing, e.g. by enabling co-simulation with Renode or Cocotb integration. It’s also one of the fastest available HDL simulators, including proprietary alternatives. It achieves that speed by generating highly optimized C++ code from a given hardware design. Verilator does a lot of work at compile-time to make the generated (‘verilated’) code extremely fast, such as ordering statements in an optimal way.">
<meta name=twitter:site content="@chipsalliance">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-H0KF2YZTR7"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-H0KF2YZTR7')</script>
</head>
<body>
<header>
<div class="lfprojects position-fixed">
<a href=https://www.linuxfoundation.org/projects target=_blank rel="noopener noreferrer"><img src=/preview/190/images/lf-projects-banner-white.svg></a>
</div>
<nav class="navbar navbar-expand-lg position-fixed w-100 zindex-dropdown" id=mainnavigationBar>
<a class=navbar-brand href=/preview/190/>
<img src=/preview/190/images/chips_alliance.svg alt=Nav-Logo>
</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-default><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><line x1="3.5" y1="5.5" x2="21.5" y2="5.5" stroke="#292d32" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/><line x1="4.5" y1="12.5" x2="21.5" y2="12.5" stroke="#292d32" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.5" y1="19.5" x2="21.5" y2="19.5" stroke="#292d32" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/></svg>
</span>
<span class=navbar-toggler-toggled><svg width="20" height="20" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21.5 6.5l-15 15" stroke="#404152" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/><path d="M21.5 21.5l-15-15" stroke="#404152" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/></svg>
</span>
</button>
<div class="collapse navbar-collapse" id=navbarSupportedContent>
<ul class="navbar-nav mx-auto mb-20 mb-lg-0 navbar-nav-scroll">
<li class="nav-item dropdown">
<div class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true aria-expanded=false>
About
</div>
<div class=dropdown-menu aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/preview/190/about/who-we-are/>Who We Are</a>
<a class=dropdown-item href=/preview/190/about/members/>Members</a>
<a class=dropdown-item href=/preview/190/about/governance/>Governance</a>
<a class=dropdown-item href=/preview/190/about/faq/>FAQ</a>
<a class=dropdown-item href=/preview/190/about/contact/>Contact</a>
</div>
</li>
<li class=nav-item>
<a class=nav-link href=/preview/190/projects/>
Projects
</a>
</li>
<li class=nav-item>
<a class=nav-link href=/preview/190/events/>
Events
</a>
</li>
<li class=nav-item>
<a class=nav-link href=/preview/190/workgroups/>
Workgroups
</a>
</li>
<li class="nav-item dropdown">
<div class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true aria-expanded=false>
News
</div>
<div class=dropdown-menu aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/preview/190/categories/blog/>Blog</a>
<a class=dropdown-item href=/preview/190/categories/reports/>Reports</a>
</div>
</li>
<li class=nav-item>
<a class=nav-link href=/preview/190/join/>
Join
</a>
</li>
</ul>
</div>
<div class="d-none d-lg-block">
<div class=nav-item>
<a href=/preview/190/getting-started/ class="btn btn-sm btn-primary">Get Started</a>
</div>
</div>
</nav>
</header>
<section class=blog-details>
<div class=container>
<div class=row>
<div class=col-lg-12>
<article class=blog-single>
<div class=inner-blog-details>
<h1>Towards UVM: Using Coroutines for Low-overhead Dynamic Scheduling in Verilator</h1>
<div class=inner-blog-details-meta>
<ul class=list-unstyled>
<li class=list-inline-item>
<p>February 1, 2022</p>
</li>
<li class=list-inline-item>
<p>8 <span>minutes</span></p>
</li>
<li class=list-inline-item>
<p>1621 <span>words</span></p>
</li>
</ul>
<div class=mt-2>
<a href=https://chipsalliance.org/preview/190/tags/project-update class="badge bg-light text-dark me-1">#project-update</a>
<a href=https://chipsalliance.org/preview/190/tags/verilator class="badge bg-light text-dark me-1">#verilator</a>
<a href=https://chipsalliance.org/preview/190/tags/uvm class="badge bg-light text-dark me-1">#uvm</a>
</div>
</div>
</div>
<div class="rounded-box mb-xxl-11 mb-8">
<img src=https://chipsalliance.org/preview/190/news/towards-uvm-using-coroutines/share.png class=w-100 alt=featured-image>
</div>
<div><p><em>This post was originally published at <a href=https://antmicro.com/blog/2021/12/coroutines-for-dynamic-scheduling-in-verilator/>Antmicro</a>.</em></p>
<p>Verilator is a popular open source SystemVerilog simulator and one of the key tools in the ASIC and FPGA ecosystem, which Antmicro is actively using and developing, e.g. by <a href=https://antmicro.com/blog/2021/09/co-simulation-for-zynq-with-renode-and-verilator/>enabling co-simulation with Renode</a> or <a href=https://antmicro.com/blog/2019/06/verilog-with-cocotb-and-verilator/>Cocotb integration</a>. It’s also one of the fastest available HDL simulators, including proprietary alternatives. It achieves that speed by generating highly optimized C++ code from a given hardware design. Verilator does a lot of work at compile-time to make the generated (‘verilated’) code extremely fast, such as ordering statements in an optimal way.</p>
<p><img src=verilation-diagram.svg alt="Verilation diagram"></p>
<p>This static ordering of code also means that support for some SystemVerilog features has been sacrificed to make Verilator so performant. Namely, Verilator does not support what is known as the stratified scheduler, an algorithm that specifies the correct order of execution of SystemVerilog designs. This algorithm is dynamic by nature, and does not fit with Verilator’s static approach.</p>
<p>Because of this, it doesn’t support <a href=https://en.wikipedia.org/wiki/Universal_Verification_Methodology>UVM</a>, a widely-used framework for testing hardware design. Testbenches for Verilator have to be written using C++, which is not ideal – you shouldn’t have to know how to program in C++ in order to use a SystemVerilog simulator. Many ASIC projects out there are not able to take advantage of Verilator, because verification in this space is very often done with UVM. This is a gap that together with Western Digital, Google and the entire CHIPS Alliance we have been working to close, to enable fully open source, cloud-scalable verification usable by the broad ASIC industry.</p>
<h2 id=a-milestone-towards-open-source-uvm>A milestone towards open source UVM</h2>
<p>Some of the key features UVM requires are dynamically-triggered event variables and delays. To support them, we introduced to Verilator what we call a dynamic scheduler with a <a href=https://github.com/antmicro/verilator-dynamic-scheduler-examples>proof-of-concept implementation</a> which we described in more detail in a <a href=https://antmicro.com/blog/2021/05/dynamic-scheduling-in-verilator/>previous blog note earlier this year</a>. Essentially, it enabled us to suspend execution of SystemVerilog processes when waiting for delays to finish or events to be triggered, thus postponing some of the scheduling from compile-time to runtime.</p>
<pre tabindex=0><code>initial forever begin
    @ping;
    #1 -&gt;pong;
end

initial forever begin
    #1 -&gt;ping;
    @pong;
end
</code></pre><p>That thread-based implementation worked, but it required us to run each process in a design in a separate thread, using mutexes and condition variables to facilitate communication. With a working solution in hand, which proved that what we set out to do was possible, we started thinking about a different approach which would allow us to avoid the significant performance overhead introduced by threads and hopefully also simplify the implementation. That’s when coroutines came up as a possible solution.</p>
<h2 id=what-is-a-coroutine>What is a coroutine?</h2>
<p>The concept of coroutines <a href=https://en.wikipedia.org/wiki/Coroutine>has been around for decades</a>. Arguably, most programmers have used them, knowingly or not. They are available in some form for most modern programming languages, and now they are also included in the newest C++20 standard. But what are they exactly?</p>
<p>Normally, when a function or procedure is called, it needs to finish execution in order for the control flow to go back to a previously executed function. This is reflected in the way the call stack works. A coroutine is a generalization of the concept of a function, but it differs in that its execution can be paused at any point, and resumed from any other point in the program, even from a different thread. Implementations vary, but often this is achieved by allocating coroutine state on the heap.</p>
<p><img src=coroutines.svg alt="Diagram depicting the call stack and coroutine state"></p>
<p>Unlike threads which are commonly used in desktop operating systems, coroutines are a form of cooperative multitasking, meaning that they have to yield control by themselves – there is no scheduler controlling them from the outside. A programmer needs to specify when and where a coroutine should resume execution.</p>
<p>A popular use case for coroutines is writing generators. As the name suggests, a generator is used for generating some set of values, but instead of returning them all at once, it yields them one by one to the function that called the generator.</p>
<pre tabindex=0><code>generator&lt;uint64_t&gt; fib(int n) {
    uint64_t a = 0, b = 1;
    for (int i = 0; i &lt; n; i++) {
        b = b + exchange(a, b);
        co_yield a;
    }
}
</code></pre><pre tabindex=0><code>for (uint64_t n : fib(40))
    printf(&quot;%d\n&quot;, n);
</code></pre><p>Coroutines are also useful for asynchronous programming, for writing functions that start their execution on one thread, but continue on another (i.e. a background thread intended for heavy computation).</p>
<pre tabindex=0><code>ui_task click_compute() {
    label = &quot;Computing...&quot;;
    co_await compute();
    label = &quot;Finished!&quot;;
}
</code></pre><p>Currently, coroutines are supported by many C++ compilers, including GCC 11 and Clang 13 (which offers experimental support). It’s worth mentioning that Clang is excellent at optimizing them: if a coroutine does not outlive the calling function’s stack frame, and its state object’s size is known at compile time, the heap allocation can be elided. Coroutine state is then simply stored on the stack. This gives Clang a significant performance edge over GCC in some cases, such as when using generators.</p>
<h2 id=coroutines-for-dynamic-scheduling>Coroutines for dynamic scheduling</h2>
<p>From the get-go, coroutines seemed like a good fit for dynamic scheduling of SystemVerilog in Verilator. As previously mentioned, they follow the cooperative model of multitasking, which is sufficient for handling delays and events in SV processes. Preemption is not necessary, as there is no danger of starving a task. That is because all SystemVerilog processes should yield in a given time slot either after they finish or when they’re awaiting an event.</p>
<p>A significant drawback of threads, which was what the initial implementation was based on, is that it’s not possible to spawn thousands of them, one for each process in a design. However, it is possible to spawn thousands of coroutines, and that number is only bound by the amount of RAM available to the user. Also, with coroutines, one does not have to worry about multithreading problems like data races. All multitasking can be done on one thread.</p>
<p>The only issue with coroutines is the allocation of coroutine state. However, there are ways to mitigate that by using a custom allocator, as well as only using coroutines for the parts of a design that actually require it. After all, dynamic scheduling is not relevant to the synthesizable subset of SystemVerilog.</p>
<p>Thus, we decided to go ahead and replace threads with coroutines in our implementation. The new approach immediately proved to be easier to work with, and development pace increased significantly. The new version already surpassed the thread-based implementation in completeness as well as performance, and is <a href=https://github.com/antmicro/verilator-dynamic-scheduler-tests>available here</a>. Let’s take a closer look at how it works.</p>
<h2 id=implementation>Implementation</h2>
<pre tabindex=0><code>initial forever begin
    @ping;
    #1;
    -&gt;pong;
end
</code></pre><pre tabindex=0><code>while (true) {
    co_await ping;
    co_await 1;
    resume(pong);
}
</code></pre><p>The general idea for the implementation was to reflect the behavior of SystemVerilog delay and event trigger statements in the <code>co_await</code> statement in C++20. This statement is responsible for suspending coroutines, and we use it to suspend SystemVerilog processes represented by coroutines in a verilated design.</p>
<p>When a delay is encountered, the current coroutine (or process) is suspended and put into a queue. When the awaited time comes, the corresponding coroutine is removed from the queue and resumed.</p>
<p><img src=coroutines-diagram2.svg alt="Diagram depicting how delays are handled"></p>
<p>Event variables work in a similar way. When we are awaiting an event, we suspend the current coroutine and put it in what we call an event dispatcher. If the event is triggered at a later point, we inform the event dispatcher which resumes the corresponding coroutine.</p>
<p><img src=coroutines-diagram1.svg alt="Diagram depicting how event variables are handled"></p>
<p>With all this, the C++ code that Verilator generates for delays and event statements is very similar to the original SystemVerilog source code.</p>
<pre tabindex=0><code>initial forever begin
    @ping;
    #10;
    -&gt;pong;
end
</code></pre><p>This SystemVerilog corresponds to the following C++ code. The snippet shown here is simplified for readability, but the structure of the verilated code is preserved.</p>
<pre tabindex=0><code>Coroutine initial() {
    while (true) {
        co_await eventDispatcher[&amp;ping];
        co_await delayedQueue[TIME() + 10];
        eventDispatcher.trigger(&amp;pong);
    }
}
</code></pre><p>As mentioned before, one of the main reasons for the switch to coroutines is performance. The original, thread-based implementation was hundreds of times slower than vanilla Verilator when simulating CHIPS Alliance’s <a href=https://github.com/chipsalliance/Cores-SweRV>SweRV EH1 core</a>. Just replacing threads with coroutines resulted in 3-time speedup in SWeRV. Further optimization, the most crucial part being detecting which parts of a design need dynamic scheduling, resulted in indistinguishable performance between vanilla Verilator and our version when using Clang for verilated code compilation.</p>
<p>Next steps and future goals
There is still more work to be done. We are continuously working on improving the dynamic scheduler in the following areas:</p>
<p>working out some remaining edge cases,
making it work with Verilator’s built-in multithreading solution,
adding new test cases to push these new features to their limits.
Our goal is to provide the dynamic scheduler in Verilator as an optional scheduler that users can enable if they want more SystemVerilog compatibility. Of course users should bear in mind that it is not as well-tested as Verilator’s default behavior, but this will most likely improve as we find more practical use cases to make use of the solution.</p>
<p>Naturally, many more features are needed to provide full UVM support. This, among others, includes:</p>
<ul>
<li>the built-in <code>process</code> class, which is used for controlling the behavior of a SystemVerilog process,</li>
<li>randomized constraints, which let the user generate test data easily by specifying constraints for random generation of said data,</li>
<li>better support for assertions, which are statements that allow for verifying that certain conditions are fulfilled by a tested design.</li>
</ul>
<p>The dynamic scheduler is part of a bigger undertaking driven by Antmicro within the CHIPS Alliance to create fully open source toolchains and flows for FPGA and ASIC development. Together with <a href=https://antmicro.com/blog/2021/10/openlane-asic-build-flow-with-systemverliog-support/>Surelog/UHDM</a>, a project aiming at providing a complete SystemVerilog parsing and elaboration solution, this brings us closer to being able to simulate, test and verify designs which use UVM with entirely open source tools.</p>
</div>
</article>
</div>
</div>
</div>
</section>
<section class="blog-related position-relative">
<div class=container>
<div class=row>
<div class=col-md-12>
<div class=blog-section>
<h2 class=blog-section-title>Recent News</h2>
</div>
</div>
</div>
<div class=row>
<div class="col-lg-4 col-md-6">
<article class=blog-post>
<div class=blog-post-thumb>
<a href=/preview/190/news/ocp-october2025/>
<img src=https://chipsalliance.org/preview/190/news/ocp-october2025/ocp-c48.png alt=blog-thumb loading=lazy>
</a>
</div>
<div class=blog-post-content>
<div class=blog-post-tag>
<a href=https://chipsalliance.org/preview/190/categories/blog>Blog</a>
</div>
<div class=blog-post-date>
October 10, 2025
</div>
<div class=blog-post-title>
<a href=/preview/190/news/ocp-october2025/>CHIPS Alliance at the 2025 OCP Global Summit</a>
</div>
</div>
</article>
</div>
<div class="col-lg-4 col-md-6">
<article class=blog-post>
<div class=blog-post-thumb>
<a href=/preview/190/news/coverage-dashboards-for-veer-and-caliptra/>
<img src=https://chipsalliance.org/preview/190/news/coverage-dashboards-for-veer-and-caliptra/Coverview--chips--blog-sm.png alt=blog-thumb loading=lazy>
</a>
</div>
<div class=blog-post-content>
<div class=blog-post-tag>
<a href=https://chipsalliance.org/preview/190/categories/blog>Blog</a>
</div>
<div class=blog-post-date>
May 22, 2025
</div>
<div class=blog-post-title>
<a href=/preview/190/news/coverage-dashboards-for-veer-and-caliptra/>Generating interactive coverage dashboards for VeeR and Caliptra with Coverview</a>
</div>
</div>
</article>
</div>
<div class="col-lg-4 col-md-6">
<article class=blog-post>
<div class=blog-post-thumb>
<a href=/preview/190/news/tac-whitepaper/>
<img src=https://chipsalliance.org/preview/190/news/tac-whitepaper/chips-alliance-whitepaper.jpg alt=blog-thumb loading=lazy>
</a>
</div>
<div class=blog-post-content>
<div class=blog-post-tag>
<a href=https://chipsalliance.org/preview/190/categories/blog>Blog</a>
</div>
<div class=blog-post-date>
April 28, 2025
</div>
<div class=blog-post-title>
<a href=/preview/190/news/tac-whitepaper/>The Next Chapter in Open Source Silicon- Download the CHIPS Alliance White Paper</a>
</div>
</div>
</article>
</div>
</div>
</div>
</section>
<footer class="footer pt-xxl-19 pt-8 pb-sm-7 pb-5" id=footer>
<div class=container-fluid>
<div class=footer-wrapper>
<div class=row>
<div class="col-12 col-lg-4 me-auto order-2 order-lg-1">
<div class="footer-logo mt-7 mt-md-0 mb-5">
<a href=/preview/190/ class=chips-logo-link>
<img src=/preview/190/images/chips-logo-white.svg alt="CHIPS Allaince Logo">
</a>
<a href=https://www.linuxfoundation.org class=lf-logo-link>
<img src=/preview/190/images/lf-stacked-white.svg alt="Linux Foundation Logo">
</a>
</div>
<div class=social-icon>
<ul class=list-unstyled>
<li>
<a href=https://twitter.com/chipsalliance> <i class=ph-twitter-logo></i> </a>
</li>
<li>
<a href=https://github.com/chipsalliance> <i class=ph-github-logo></i> </a>
</li>
<li>
<a href=https://www.linkedin.com/company/chipsalliance/> <i class=ph-linkedin-logo></i> </a>
</li>
</ul>
</div>
<div class="footer-logo mt-7 mt-md-0">
<p>
© Copyright <span>2025</span> CHIPS Alliance
The Linux Foundation® . All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage>Trademark Usage</a> page. Linux is a registered trademark of Linus Torvalds. <a href=http://www.linuxfoundation.org/privacy>Privacy Policy</a> and <a href=http://www.linuxfoundation.org/terms>Terms of Use</a>.
</p>
</div>
</div>
<div class="col-6 col-md-4 col-sm-4 col-lg-2 order-1">
<div class=footer-widget>
<h3>About</h3>
<ul class=list-unstyled>
<li>
<a href=/preview/190/about/who-we-are/>Who We Are</a>
</li>
<li>
<a href=/preview/190/about/members/>Members</a>
</li>
<li>
<a href=https://members.chipsalliance.org/>Member Support</a>
</li>
<li>
<a href=/preview/190/about/governance/>Governance</a>
</li>
<li>
<a href=/preview/190/about/faq/>FAQ</a>
</li>
<li>
<a href=/preview/190/about/contact/>Contact</a>
</li>
</ul>
</div>
</div>
<div class="col-6 col-md-4 col-sm-4 col-lg-2 order-1">
<div class=footer-widget>
<h3>Community</h3>
<ul class=list-unstyled>
<li>
<a href=/preview/190/projects/>Projects</a>
</li>
<li>
<a href=/preview/190/getting-started/>Getting Started</a>
</li>
<li>
<a href=/preview/190/events/>Events</a>
</li>
<li>
<a href=/preview/190/workgroups/>Workgroups</a>
</li>
</ul>
</div>
</div>
<div class="col-6 col-md-4 col-sm-4 col-lg-2 order-1">
<div class=footer-widget>
<h3>News</h3>
<ul class=list-unstyled>
<li>
<a href=/preview/190/categories/blog/>Blog</a>
</li>
<li>
<a href=/preview/190/categories/reports/>Reports</a>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</footer>
<script src=/preview/190/vendor/jQuery/jquery.min.js></script>
<script src=/preview/190/vendor/bootstrap/bootstrap.bundle.min.js></script>
<script src=/preview/190/vendor/counter-up/countup.js></script>
<script src=/preview/190/vendor/magnific-popup/magnific-popup.min.js></script>
<script src=/preview/190/js/script.js></script>
</body>
</html>